---
layout:     post                    # 使用的布局（不需要改）
title:      《The C Programming language》笔记              # 标题 
subtitle:   getchar与EOF  #副标题
date:       2019-09-07              # 时间
author:     YH                      # 作者
header-img: img/post-bg-2015.jpg    #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:                               #标签
    - The C Programming language
---
一、对getchar的两点总结：
1. getchar是以行为单位进行存取的。
当调用getchar函数读取输入时，只有当输入字符为换行符'/n'或文件结束符EOF时，getchar才会停止执行，整个程序将会往下执行。并且，如果输入行是以EOF结束的（EOF之前不是换行符），则EOF会被“吃掉”（即不会被getchar读取到）。譬如下面程序段：
while((c = getchar()) != EOF){
putchar(c);
}
执行程序，输入：abc，然后回车。则程序就会去执行puchar(c)，然后输出abc和一个回车。然后可以继续输入，再次遇到换行符的时候，程序又会把 那一行的输入的字符输出在终端上。令人迷惑的是，getchar不是以字符为单位读取的吗？那么，既然我输入了第一个字符a，肯定满足while循环(c = getchar()) != EOF的条件，那么应该执行putchar(c)在终端输出一个字符a。但是程序就偏偏不这样执行，而是必需读到一个换行符或者文件结束符EOF才进行一次输出。
 
造成这种结果的一种解释是，输入终端驱动处于一次一行 的模式下。也就是虽然getchar()和putchar()确实是按照每次一个字符进行的。但是终端驱动处于一次一行的模式，它的输入只有到'/n'或 者EOF时才结束。在本例中，程序段调用了getchar函数，则控制权从程序段转移到getchar函数，而getchar函数要依赖于操作系统的驱动 来读取输入，没遇到换行符或者EOF，驱动不会通知getchar函数，getchar函数处于“阻 塞”状态。而遇到换行符或者EOF后，getchar函数解除“阻塞”，读取一个字符，控制权返回程 序段，执行putchar函数，循环执行。直到遇到EOF字符或者这行输入全部处理完。

2. getchar()的返回值一般情况下是非负 值，但也可能是负值，即返回EOF。这个EOF在函数库里一般定义为-1。正确的定义方法如下(K&R C中特别提到了这个问题)：
int c;
c = getchar();
二、EOF的两点总结(主要指普通终端中的EOF)
1. EOF作为文件结束符时的情况：
EOF虽然是文件结束符，但并不是在任何情况下输入Ctrl+D(Windows下Ctrl+Z)都能够实现文件结束的功能，只有在下列的条件下，才作为文件结束符。
(1)遇到getcahr函数执行时，要输入第一个字符时就直接输入Ctrl+D；
(2)在前面输入的字符为换行符时， 接着输入Ctrl+D；
(3)在前面有字符输入且不为换行符时，要连着输入两次Ctrl+D，这时第二次输入的Ctrl+D起到文件结束符的功能，至于第一次的
Ctrl+D作为行结束符（如1.1所讲）。
其实，这三种情况都可以总结为只有在getchar()提示新的一次输入时， 直接输入Ctrl+D才相当于文件结束符。
2. EOF作为行结束符时的情况，这时候输入Ctrl+D作为行结束的标志能结束getchar()的“阻塞”，使getchar()逐个字符读入，但是EOF会被“吃掉”，并不会被读取。
 
以上面的代码段为例， 如果执行时输入abc，然后 Ctrl+D，程序输出结果为：
abcabc
注意:第一组abc是你从终端输入的，然后输入Ctrl+D，getchar逐个字符读取并逐个输出打印出第二组abc，同时光标停在第二组字符的c后面，然后可以进行新一次的输入。这时如果再次输入Ctrl+D，就会起到了文件结束符的作用，因为EOF是一行输入的第一个字符。如果输入abc之后，然后回车，输入换行符的话，则终端显示为：
abc'/n'
abc'/n'
//第三行
其中第一行为你是终端输入的，第二行是终端输出（含换行符），光标停在了第三行处，等待新一次的终端输入。从这里也 可以看出Ctrl+D和换行符分别作为行结束符时，输出的不同结果。

原作者：竹影清风
来源：http://cunlau.cnblogs.com/
